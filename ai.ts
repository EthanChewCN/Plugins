import { Plugin } from "@utils/pluginBase";
import { Api } from "telegram";
import axios from "axios";
import { JSONFilePreset } from "lowdb/node";
import * as path from "path";
import * as fs from "fs";
import { createDirectoryInAssets } from "@utils/pathHelpers";

// ---- storage ----
type Provider = { apiKey: string; baseUrl: string };
type Compat = "openai" | "gemini" | "claude";
type Models = { chat: string; search: string; image: string; tts: string; voice: string };
type Telegraph = { enabled: boolean; limit: number; token: string; posts: { title: string; url: string; createdAt: string }[] };
type DB = { providers: Record<string, Provider>; compat: Record<string, Compat>; models: Models; contextEnabled: boolean; collapse: boolean; telegraph: Telegraph; histories: Record<string, { role: string; content: string }[]> };

const MAX_MSG = 4096;
const trimBase = (u: string) => u.replace(/\/$/, "");
const html = (t: string) => t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
const nowISO = () => new Date().toISOString();

class Store {
  static db: any = null;
  static data: DB = {
    providers: {},
    compat: {},
    models: { chat: "", search: "", image: "", tts: "", voice: "" },
    contextEnabled: false,
    collapse: false,
    telegraph: { enabled: false, limit: 0, token: "", posts: [] },
    histories: {}
  };
  static baseDir: string = "";
  static file: string = "";
  static async init() {
    if (this.db) return;
    this.baseDir = createDirectoryInAssets("ai");
    this.file = path.join(this.baseDir, "config.json");
    this.db = await JSONFilePreset<DB>(this.file, {
      providers: {}, compat: {},
      models: { chat: "", search: "", image: "", tts: "", voice: "" },
      contextEnabled: false, collapse: false,
      telegraph: { enabled: false, limit: 0, token: "", posts: [] },
      histories: {}
    });
    this.data = this.db.data;
  }
  static async write() { await this.db.write(); }
}

// ---- helpers ----
function applyWrap(s: string, collapse?: boolean) { 
  if (!collapse) return s; 
  // If content already uses blockquote-based collapsible style, avoid double-wrapping with spoiler
  if (s.includes("<blockquote")) return s; 
  return `<span class="tg-spoiler">${s}</span>`; 
}
// Ensure footer is not collapsed: append outside spoiler via sendLong helpers
async function sendLong(msg: Api.Message, text: string, opts?: { collapse?: boolean }, postfix?: string) {
  const PAGE_EXTRA = 32; const WRAP_EXTRA = opts?.collapse ? 64 : 0;
  const parts = splitMessage(text, PAGE_EXTRA + WRAP_EXTRA);
  if (parts.length === 1) { await msg.edit({ text: applyWrap(parts[0], opts?.collapse) + (postfix || ""), parseMode: "html" }); return; }
  await msg.edit({ text: applyWrap(parts[0] + `\n\nüìÑ (1/${parts.length})`, opts?.collapse), parseMode: "html" });
  for (let i = 1; i < parts.length; i++) {
    const isLast = i === parts.length - 1;
    const chunkText = applyWrap(parts[i] + `\n\nüìÑ (${i + 1}/${parts.length})`, opts?.collapse) + (isLast ? (postfix || "") : "");
    await msg.reply({ message: chunkText, parseMode: "html" });
  }
}
async function sendLongReply(msg: Api.Message, replyToId: number, text: string, opts?: { collapse?: boolean }, postfix?: string) {
  const PAGE_EXTRA = 32; const WRAP_EXTRA = opts?.collapse ? 64 : 0;
  const parts = splitMessage(text, PAGE_EXTRA + WRAP_EXTRA);
  if (!msg.client) return;
  const peer = msg.peerId;
  if (parts.length === 1) { await msg.client.sendMessage(peer, { message: applyWrap(parts[0], opts?.collapse) + (postfix || ""), parseMode: "html", replyTo: replyToId }); return; }
  await msg.client.sendMessage(peer, { message: applyWrap(parts[0] + `\n\nüìÑ (1/${parts.length})`, opts?.collapse), parseMode: "html", replyTo: replyToId });
  for (let i = 1; i < parts.length; i++) {
    const isLast = i === parts.length - 1;
    const chunkText = applyWrap(parts[i] + `\n\nüìÑ (${i + 1}/${parts.length})`, opts?.collapse) + (isLast ? (postfix || "") : "");
    await msg.client.sendMessage(peer, { message: chunkText, parseMode: "html", replyTo: replyToId });
  }
}
function extractText(m: Api.Message | null | undefined): string {
  if (!m) return "";
  const anyM: any = m as any;
  return (anyM.message || anyM.text || anyM.caption || "");
}
function splitMessage(text: string, reserve = 0): string[] {
  const limit = Math.max(1, MAX_MSG - Math.max(0, reserve));
  if (text.length <= limit) return [text];
  const parts: string[] = [];
  let cur = "";
  for (const line of text.split("\n")) {
    if (line.length > limit) {
      if (cur) { parts.push(cur); cur = ""; }
      for (let i = 0; i < line.length; i += limit) parts.push(line.slice(i, i + limit));
      continue;
    }
    const next = cur ? cur + "\n" + line : line;
    if (next.length > limit) { parts.push(cur); cur = line; } else { cur = next; }
  }
  if (cur) parts.push(cur);
  return parts;
}
function detectCompat(name: string, model: string, baseUrl: string): Compat {
  const m = (model || "").toLowerCase(); const host = (baseUrl || "").toLowerCase();
  if (/claude/.test(m) || /anthropic/.test(host)) return "claude";
  if (/gemini|google/.test(m) || /generativelanguage/.test(host)) return "gemini";
  return "openai";
}
function pick(kind: keyof Models): { provider: string; model: string } | null {
  const s = Store.data.models[kind]; if (!s) return null; const i = s.indexOf(" "); if (i <= 0) return null;
  const provider = s.slice(0, i); const model = s.slice(i + 1);
  return { provider, model };
}
function providerOf(name: string): Provider | null { return Store.data.providers[name] || null; }
function footer(model: string, extra?: string) { const src = model.toLowerCase().includes("claude") ? "Anthropic Claude" : model.toLowerCase().includes("gemini") ? "Google Gemini" : "OpenAI"; return `\n\n<i>Powered by ${src}${extra ? " " + extra : ""}</i>`; }
function ensureDir() { if (!fs.existsSync(Store.baseDir)) fs.mkdirSync(Store.baseDir, { recursive: true }); }
function chatIdStr(msg: Api.Message) { return String((msg.peerId as any)?.channelId || (msg.peerId as any)?.userId || (msg.peerId as any)?.chatId || "global"); }
function histFor(id: string) { return Store.data.histories[id] || []; }
function pushHist(id: string, role: string, content: string) {
  if (!Store.data.histories[id]) Store.data.histories[id] = [];
  Store.data.histories[id].push({ role, content });
  const h = Store.data.histories[id];
  while (h.length > 20) h.shift();
}
// Ê∑ªÂä†Êõ¥Á≤æÁªÜÁöÑÊñáÊú¨Ê∏ÖÊ¥ó‰∏éHTMLÂÆâÂÖ®ÂåñÔºåÂπ∂Â∞Ü‰ª• "> " ÂºÄÂ§¥ÁöÑË°åËΩ¨Êç¢‰∏∫ blockquote
function cleanTextBasic(t: string): string {
  if (!t) return "";
  return t
    .replace(/\uFEFF/g, "")
    .replace(/[\uFFFC\uFFFF\uFFFE]/g, "")
    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "")
    .replace(/\r\n/g, "\n")
    .replace(/\u200B|\u200C|\u200D|\u2060/g, "")
    .normalize('NFKC');
}
function escapeAndFormatForTelegram(raw: string): string {
  const cleaned = cleanTextBasic(raw || "");
  // ÂÖàËøõË°åHTMLËΩ¨‰πâÔºå‰øùËØÅÂÆâÂÖ®
  let escaped = html(cleaned);
  // Â∞Ü‰ª• "> " ÂºÄÂ§¥ÁöÑË°åÔºàÂ∑≤ËΩ¨‰πâ‰∏∫ &gt; ÔºâÊõøÊç¢‰∏∫ blockquote
  escaped = escaped.replace(/^&gt;\s?(.+)$/gm, '<blockquote>$1</blockquote>');
  return escaped;
}
// Helper to decide if an error indicates missing route; used for /v1beta -> /v1 fallback
function isRouteError(err: any): boolean {
  const s = err?.response?.status;
  const txt = String(err?.response?.data || err?.message || "").toLowerCase();
  return s === 404 || s === 405 || (s === 400 && /(unknown|not found|invalid path|no route)/.test(txt));
}
// ÈÄöÁî®ÔºöGemini /v1beta ‚Üí /v1 ÂõûÈÄÄËØ∑Ê±ÇÂä©Êâã
async function geminiRequestWithFallback(p: Provider, path: string, axiosConfig: any): Promise<any> {
  const base = trimBase(p.baseUrl);
  try {
    const r = await axios({ url: base + `/v1beta${path}`, ...axiosConfig });
    return r.data;
  } catch (err) {
    if (!isRouteError(err)) throw err;
    const r2 = await axios({ url: base + `/v1${path}`, ...axiosConfig });
    return r2.data;
  }
}
function formatQA(qRaw: string, aRaw: string, footerHtml?: string): string {
  const expandAttr = Store.data.collapse ? " expandable" : "";
  const qEsc = escapeAndFormatForTelegram(qRaw);
  const aEsc = escapeAndFormatForTelegram(aRaw);
  const Q = `<b>Q:</b>\n<blockquote${expandAttr}>${qEsc}</blockquote>`;
  const A = `<b>A:</b>\n<blockquote${expandAttr}>${aEsc}</blockquote>`;
  // Do not append footer here; it will be added outside spoiler by sendLong helpers
  return `${Q}\n\n${A}`;
}

// ---- telegraph (minimal) ----
function toNodes(text: string) { return JSON.stringify(text.split("\n\n").map(p => ({ tag: "p", children: [p] }))); }
async function ensureTGToken(): Promise<string> {
  if (Store.data.telegraph.token) return Store.data.telegraph.token;
  const resp = await axios.post("https://api.telegra.ph/createAccount", null, { params: { short_name: "TeleBoxAI", author_name: "TeleBox" } });
  const t = resp.data?.result?.access_token || ""; Store.data.telegraph.token = t; await Store.write(); return t;
}
async function createTGPage(title: string, text: string): Promise<string | null> {
  try {
    const token = await ensureTGToken(); if (!token) return null;
    const resp = await axios.post("https://api.telegra.ph/createPage", null, {
      params: { access_token: token, title, content: toNodes(text), return_content: false }
    });
    return resp.data?.result?.url || null;
  } catch { return null; }
}

// ---- provider adapters ----
async function chatOpenAI(p: Provider, model: string, msgs: { role: string; content: string }[], maxTokens?: number) {
  const url = trimBase(p.baseUrl) + "/v1/chat/completions";
  const r = await axios.post(url, { model, messages: msgs, max_tokens: maxTokens || 1024 }, { headers: { Authorization: `Bearer ${p.apiKey}` } });
  return r.data?.choices?.[0]?.message?.content || "";
}
async function chatClaude(p: Provider, model: string, msgs: { role: string; content: string }[], maxTokens?: number) {
  const url = trimBase(p.baseUrl) + "/v1/messages";
  const r = await axios.post(url, { model, max_tokens: maxTokens || 1024, messages: msgs.map(m => ({ role: m.role === "assistant" ? "assistant" : "user", content: m.content })) }, { headers: { "x-api-key": p.apiKey, "anthropic-version": "2023-06-01" } });
  return r.data?.content?.[0]?.text || r.data?.message?.content?.[0]?.text || "";
}
async function chatGemini(p: Provider, model: string, msgs: { role: string; content: string }[]) {
  const path = `/models/${encodeURIComponent(model)}:generateContent`;
  const data = await geminiRequestWithFallback(p, path, {
    method: "POST",
    data: { contents: [{ parts: msgs.map(m => ({ text: (m.role === "user" ? "" : "") + m.content })) }] },
    params: { key: p.apiKey }
  });
  const parts = data?.candidates?.[0]?.content?.parts || [];
  return parts.map((x: any) => x.text || "").join("");
}

// Êñ∞Â¢ûÔºöÂ∏¶ÂõæÁâáÁöÑËÅäÂ§©ÔºàOpenAIÔºâ
async function chatVisionOpenAI(p: Provider, model: string, imageB64: string, prompt?: string) {
  const url = trimBase(p.baseUrl) + "/v1/chat/completions";
  const content = [
    { type: "text", text: prompt || "Áî®‰∏≠ÊñáÊèèËø∞Ê≠§ÂõæÁâá" },
    { type: "image_url", image_url: { url: `data:image/png;base64,${imageB64}` } }
  ];
  const r = await axios.post(
    url,
    { model, messages: [{ role: "user", content }] },
    { headers: { Authorization: `Bearer ${p.apiKey}` } }
  );
  return r.data?.choices?.[0]?.message?.content || "";
}

// Êñ∞Â¢ûÔºöÂ∏¶ÂõæÁâáÁöÑËÅäÂ§©ÔºàGeminiÔºâ
async function chatVisionGemini(p: Provider, model: string, imageB64: string, prompt?: string) {
  const path = `/models/${encodeURIComponent(model)}:generateContent`;
  const data = await geminiRequestWithFallback(p, path, {
    method: "POST",
    data: {
      contents: [
        {
          role: "user",
          parts: [
            { inlineData: { mimeType: "image/png", data: imageB64 } },
            { text: prompt || "Áî®‰∏≠ÊñáÊèèËø∞Ê≠§ÂõæÁâá" }
          ]
        }
      ]
    },
    params: { key: p.apiKey }
  });
  const parts = data?.candidates?.[0]?.content?.parts || [];
  return parts.map((x: any) => x.text || "").join("");
}
// Áªü‰∏ÄÁöÑËßÜËßâËÅäÂ§©ÂÖ•Âè£ÔºöÊ†πÊçÆ compat Ë∑ØÁî±Âà∞ÂÖ∑‰ΩìÂÆûÁé∞
async function chatVision(p: Provider, compat: string, model: string, imageB64: string, prompt?: string): Promise<string> {
  if (compat === "openai") return chatVisionOpenAI(p, model, imageB64, prompt);
  if (compat === "gemini") return chatVisionGemini(p, model, imageB64, prompt);
  // ÂÖ∂‰ªñ‰∏çÊîØÊåÅËßÜËßâÁöÑÊúçÂä°ÂïÜÔºöÈÄÄÂåñ‰∏∫Á∫ØÊñáÊú¨ÊèèËø∞
  return chatOpenAI(p, model, [{ role: "user", content: prompt || "ÊèèËø∞ËøôÂº†ÂõæÁâá" } as any] as any);
}

// Êñ∞Â¢ûÔºöÂ∏¶ÂõæÁâáÁöÑËÅäÂ§©ÔºàGeminiÔºâ
async function imageOpenAI(p: Provider, model: string, prompt: string): Promise<string> {
  const url = trimBase(p.baseUrl) + "/v1/images/generations";
  try {
    const r = await axios.post(
      url,
      { model, prompt, response_format: "b64_json", size: "1024x1024", n: 1 },
      { headers: { Authorization: `Bearer ${p.apiKey}` }, timeout: 60000 }
    );
    const b64 = r.data?.data?.[0]?.b64_json || "";
    if (!b64) throw new Error("ÊúçÂä°Êó†ÊúâÊïàËæìÂá∫");
    return b64;
  } catch (err: any) {
    const status = err?.response?.status;
    const body = err?.response?.data;
    const msg = body?.error?.message || body?.message || err?.message || String(err);
    throw new Error(`ÂõæÁâáÁîüÊàêÂ§±Ë¥•(${status || "ÁΩëÁªúÈîôËØØ"}): ${msg}`);
  }
}
async function ttsOpenAI(p: Provider, model: string, input: string, voice: string): Promise<Buffer> {
  const url = trimBase(p.baseUrl) + "/v1/audio/speech";
  const r = await axios.post(url, { model, input, voice, format: "ogg" }, { headers: { Authorization: `Bearer ${p.apiKey}` }, responseType: "arraybuffer" });
  return Buffer.from(r.data);
}
// Gemini image
async function imageGemini(p: Provider, model: string, prompt: string): Promise<{ image?: Buffer; text?: string; mime?: string }> {
  const path = `/models/${encodeURIComponent(model)}:generateContent`;
  try {
    const data = await geminiRequestWithFallback(p, path, {
      method: "POST",
      data: {
        contents: [ { role: "user", parts: [{ text: prompt }] } ],
        generationConfig: { responseModalities: ["TEXT", "IMAGE"] }
      },
      params: { key: p.apiKey }
    });
    const parts = data?.candidates?.[0]?.content?.parts || [];
    let text: string | undefined; let image: Buffer | undefined; let mime: string | undefined;
    for (const part of parts) {
      if ((part as any)?.text) text = String((part as any).text);
      if ((part as any)?.inlineData?.data) { image = Buffer.from((part as any).inlineData.data, "base64"); mime = (part as any).inlineData.mimeType || "image/png"; }
    }
    return { image, text, mime };
  } catch {
    return {};
  }
}
// Gemini TTS
async function ttsGemini(p: Provider, model: string, input: string, voiceName?: string): Promise<{ audio?: Buffer; mime?: string }> {
  const path = `/models/${encodeURIComponent(model)}:generateContent`;
  const voice = voiceName || "Kore";
  try {
    const data = await geminiRequestWithFallback(p, path, {
      method: "POST",
      data: {
        contents: [ { role: "user", parts: [{ text: input }] } ],
        generationConfig: {
          responseModalities: ["AUDIO"],
          speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: voice } } }
        }
      },
      params: { key: p.apiKey },
      timeout: 60000
    });
    const candidate = data?.candidates?.[0];
    const part = candidate?.content?.parts?.[0];
    if (part?.inlineData?.data) {
      const audio = Buffer.from(part.inlineData.data, "base64");
      const mime = part.inlineData.mimeType || "audio/wav";
      return { audio, mime };
    }
    return {};
  } catch {
    return {};
  }
}
// Helper: list Gemini models with /v1beta -> /v1 fallback
async function listGeminiModels(p: Provider): Promise<string[]> {
  const base = trimBase(p.baseUrl);
  try {
    const r = await axios.get(base + "/v1beta/models", { params: { key: p.apiKey } });
    return (r.data?.models || []).map((x: any) => String(x.name || '').replace(/^models\//, ''));
  } catch (err: any) {
    if (!isRouteError(err)) throw err;
    const r2 = await axios.get(base + "/v1/models", { params: { key: p.apiKey } });
    return (r2.data?.models || []).map((x: any) => String(x.name || '').replace(/^models\//, ''));
  }
}
async function callChat(kind: "chat" | "search", text: string, msg: Api.Message): Promise<{ content: string; model: string }> {
  const m = pick(kind); if (!m) throw new Error(`Êú™ËÆæÁΩÆ${kind}Ê®°ÂûãÔºåËØ∑ÂÖàÈÖçÁΩÆ`);
  const p = providerOf(m.provider); if (!p) throw new Error(`ÊúçÂä°ÂïÜ ${m.provider} Êú™ÈÖçÁΩÆ`);
  const compat = Store.data.compat[m.provider] || detectCompat(m.provider, m.model, p.baseUrl);
  const id = chatIdStr(msg); const msgs: { role: string; content: string }[] = [];
  if (Store.data.contextEnabled) msgs.push(...histFor(id));
  msgs.push({ role: "user", content: text });
  let out = "";
  if (compat === "openai") out = await chatOpenAI(p, m.model, msgs);
  else if (compat === "claude") out = await chatClaude(p, m.model, msgs);
  else out = await chatGemini(p, m.model, msgs);
  if (Store.data.contextEnabled) { pushHist(id, "user", text); pushHist(id, "assistant", out); await Store.write(); }
  return { content: out, model: m.model };
}

// ---- plugin ----
const help = `üîß <b>ü§ñ Â§öÊúçÂä°ÂïÜÊô∫ËÉΩAIÂä©Êâã</b>
üìù <b>ÁâπÊÄß</b>
ÂÖºÂÆπ Google Gemini„ÄÅOpenAI„ÄÅAnthropic Claude Ê†áÂáÜÊé•Âè£ÔºåÁªü‰∏ÄÊåá‰ª§Ôºå‰∏ÄÂ§ÑÈÖçÁΩÆÔºåÂ§öÂ§ÑÂèØÁî®„ÄÇ
‚ú® <b>‰∫ÆÁÇπ</b>
‚Ä¢ üéØ Áªü‰∏ÄÂÜôÊ≥ïÔºö<b>ÊúçÂä°ÂïÜ Ê®°Âûã</b>ÔºàÁ§∫‰æãÔºö<code>openai gpt-4o</code>„ÄÅ<code>claude claude-3-sonnet</code>„ÄÅ<code>gemini gemini-pro</code>Ôºâ
‚Ä¢ üîÄ Ê®°ÂûãÊ∑∑Áî®ÔºöÂØπËØù / ÊêúÁ¥¢ / ÂõæÁâá / ËØ≠Èü≥ ÂèØÂàÜÂà´ÊåáÂÆö‰∏çÂêåÊúçÂä°ÂïÜÁöÑÊúÄ‰Ω≥Ê®°Âûã
‚Ä¢ üß† ÂèØÈÄâ‰∏ä‰∏ãÊñáËÆ∞ÂøÜ„ÄÅüì∞ ÈïøÊñáËá™Âä®ÂèëÂ∏É Telegraph„ÄÅüßæ Ê∂àÊÅØÊäòÂè†ÊòæÁ§∫

üí¨ <b>ÂØπËØù</b>
<code>ai chat [ÈóÆÈ¢ò]</code>
‚Ä¢ Á§∫‰æãÔºö<code>ai chat ‰Ω†Â•ΩÔºåÂ∏ÆÊàëÁÆÄÂçï‰ªãÁªç‰∏Ä‰∏ã‰Ω†</code>
‚Ä¢ Á§∫‰æãÔºö<code>ai chat ÂÜô‰∏Ä‰∏™ Python ÊñêÊ≥¢ÈÇ£Â•ëÂáΩÊï∞</code>
‚Ä¢ ÊîØÊåÅÂ§öËΩÆÂØπËØùÔºàÂèØÊâßË°å <code>ai context on</code> ÂºÄÂêØËÆ∞ÂøÜÔºâ
‚Ä¢ ÊîØÊåÅÂõûÂ§çÂ∑≤ÊúâÊ∂àÊÅØÁªßÁª≠ÂØπËØù
‚Ä¢ Ë∂ÖÈïøÂõûÁ≠îÂèØËá™Âä®ËΩ¨ Telegraph

üîç <b>ÊêúÁ¥¢</b>
<code>ai search [Êü•ËØ¢]</code>
‚Ä¢ Á§∫‰æãÔºö<code>ai search 2024 Âπ¥ AI ÊäÄÊúØËøõÂ±ï</code>

üñºÔ∏è <b>ÂõæÁâá</b>
<code>ai image [ÊèèËø∞]</code>
‚Ä¢ Á§∫‰æãÔºö<code>ai image Êú™Êù•ÂüéÂ∏ÇÁöÑÁßëÂπªÂ§úÊôØ</code>

üéµ <b>ÊñáÊú¨ËΩ¨ËØ≠Èü≥</b>
<code>ai tts [ÊñáÊú¨]</code>
‚Ä¢ Á§∫‰æãÔºö<code>ai tts ‰Ω†Â•ΩÔºåËøôÊòØ‰∏ÄÊ¨°ËØ≠Èü≥ÂêàÊàêÊµãËØï</code>

üé§ <b>ËØ≠Èü≥ÂõûÁ≠î</b>
<code>ai audio [ÈóÆÈ¢ò]</code>
‚Ä¢ Á§∫‰æãÔºö<code>ai audio Áî® 30 Áßí‰ªãÁªç‰∫∫Â∑•Êô∫ËÉΩÁöÑÂèëÂ±ï</code>

üîçüé§ <b>ÊêúÁ¥¢Âπ∂ËØ≠Èü≥ÂõûÁ≠î</b>
<code>ai searchaudio [Êü•ËØ¢]</code>
‚Ä¢ Á§∫‰æãÔºö<code>ai searchaudio 2024 Âπ¥ÊúÄÊñ∞ÁßëÊäÄË∂ãÂäø</code>

üí≠ <b>ÂØπËØù‰∏ä‰∏ãÊñá</b>
<code>ai context on|off|show|del</code>

üìã <b>Ê∂àÊÅØÊäòÂè†</b>
<code>ai collapse on|off</code>

üì∞ <b>Telegraph ÈïøÊñá</b>
<code>ai telegraph on|off|limit &lt;Êï∞Èáè&gt;|list|del &lt;n|all&gt;</code>
‚Ä¢ limit &lt;Êï∞Èáè&gt;ÔºöËÆæÁΩÆÂ≠óÊï∞ÈòàÂÄºÔºà0 Ë°®Á§∫‰∏çÈôêÂà∂Ôºâ
‚Ä¢ Ëá™Âä®ÂàõÂª∫ / ÁÆ°ÁêÜ / Âà†Èô§ Telegraph ÊñáÁ´†

‚öôÔ∏è <b>Ê®°ÂûãÁÆ°ÁêÜ</b>
<code>ai model list</code> - Êü•ÁúãÂΩìÂâçÊ®°ÂûãÈÖçÁΩÆ
<code>ai model chat|search|image|tts [ÊúçÂä°ÂïÜ] [Ê®°Âûã]</code> - ËÆæÁΩÆÂêÑÂäüËÉΩÊ®°Âûã
<code>ai model voice [Èü≥Ëâ≤Âêç]</code> - ËÆæÁΩÆ TTS Èü≥Ëâ≤ÔºàÁõ¥Êé•Â°´Èü≥Ëâ≤ÂêçÔºâ
<code>ai model default</code> - Ê∏ÖÁ©∫ÊâÄÊúâÂäüËÉΩÊ®°Âûã
<code>ai model auto</code> - Êô∫ËÉΩÂàÜÈÖç chat/search/image/tts ‰∏éÈü≥Ëâ≤

üîß <b>ÈÖçÁΩÆÁÆ°ÁêÜ</b>
<code>ai config add [ÊúçÂä°ÂïÜ] [APIÂØÜÈí•] [BaseURL]</code>
<code>ai config list</code>
<code>ai config model [ÊúçÂä°ÂïÜ]</code> - Êü•ÁúãËØ•ÊúçÂä°ÂïÜÂèØÁî®Ê®°Âûã
<code>ai config update [ÊúçÂä°ÂïÜ] [apikey|baseurl] [ÂÄº]</code>
<code>ai config remove [ÊúçÂä°ÂïÜ|all]</code>

üìù <b>ÈÖçÁΩÆÁ§∫‰æã</b>
‚Ä¢ OpenAIÔºö<code>ai config add openai sk-proj-xxx https://api.openai.com</code>
‚Ä¢ DeepSeekÔºö<code>ai config add deepseek sk-xxx https://api.deepseek.com</code>
‚Ä¢ GrokÔºö<code>ai config add grok xai-xxx https://api.x.ai</code>
‚Ä¢ ClaudeÔºö<code>ai config add claude sk-ant-xxx https://api.anthropic.com</code>
‚Ä¢ GeminiÔºö<code>ai config add gemini AIzaSy-xxx https://generativelanguage.googleapis.com</code>

üìñ ‰ΩøÁî® <code>ai help short</code> Êü•ÁúãÁÆÄÂåñÊåá‰ª§`;

const helpShort = `üîß <b>AIÊô∫ËÉΩÂä©ÊâãÁÆÄ‰ª§ËØ¥Êòé</b>
Â∏∏Áî®Êåá‰ª§ÔºàÁÆÄÔºâ
- ÂØπËØùÔºö<code>ai [ÈóÆÈ¢ò]</code>
- ÊêúÁ¥¢Ôºö<code>ai s [Êü•ËØ¢]</code>
- ÂõæÁâáÔºö<code>ai img [ÊèèËø∞]</code>
- ËØ≠Èü≥Ôºö<code>ai v [ÊñáÊú¨]</code>
- ÂõûÁ≠î‰∏∫ËØ≠Èü≥Ôºö<code>ai a [ÈóÆÈ¢ò]</code> / ÊêúÁ¥¢Âπ∂ËØ≠Èü≥Ôºö<code>ai sa [Êü•ËØ¢]</code>
- ‰∏ä‰∏ãÊñáÔºö<code>ai ctx on|off</code>
- Ê®°ÂûãÔºö<code>ai m chat|search|image|tts [ÊúçÂä°ÂïÜ] [Ê®°Âûã]</code>
- ÈÖçÁΩÆÔºö<code>ai c add [ÊúçÂä°ÂïÜ] [APIÂØÜÈí•] [BaseURL]</code>

Âà´ÂêçÔºös=search, img/i=image, v/voice=tts, a=audio, sa=searchaudio, ctx=context, fold=collapse, cfg/c=config, m=model, h=help`;

class AiPlugin extends Plugin {
  description: string = `Â§öÊúçÂä°ÂïÜ AI Êèí‰ª∂\n\n${help}`;
  cmdHandlers = {
    ai: async (msg: Api.Message) => {
      await Store.init(); ensureDir();
      const text = (msg as any).text || (msg as any).message || ""; const lines = text.trim().split(/\r?\n/g); const parts = (lines[0] || "").split(/\s+/);
      const [, sub, ...args] = parts; const subl = (sub || "").toLowerCase();
      // aliases: s,img,i,voice,v,a,sa,ctx,fold,cfg,c,m,h
      const aliasMap: Record<string, string> = {
      s: "search",
      img: "image",
      i: "image",
      voice: "tts",
      v: "tts",
      a: "audio",
      sa: "searchaudio",
      ctx: "context",
      fold: "collapse",
      cfg: "config",
      c: "config",
      m: "model",
      h: "help",
      };
      const subn = aliasMap[subl] || subl;
      try {
        if (!subn || subn === "help") {
          const a0 = (args[0] || "").toLowerCase();
          const showShort = subl === "h" || a0 === "short" || a0 === "-s";
          await sendLong(msg, showShort ? helpShort : help);
          return;
        }
        // config
        if (subn === "config") {
          const a0 = (args[0] || "").toLowerCase();
          if (a0 === "add") {
            const [name, key, baseUrl] = [args[1], args[2], args[3]];
            if (!name || !key || !baseUrl) { await msg.edit({ text: "‚ùå ÂèÇÊï∞‰∏çË∂≥", parseMode: "html" }); return; }
            Store.data.providers[name] = { apiKey: key, baseUrl }; Store.data.compat[name] = detectCompat(name, "", baseUrl); await Store.write();
            await msg.edit({ text: `‚úÖ Â∑≤Ê∑ªÂä† <b>${html(name)}</b>`, parseMode: "html" }); return;
          }
          if (a0 === "list") {
            const list = Object.entries(Store.data.providers).map(([n, v]) => `‚Ä¢ <b>${html(n)}</b> - key:${v.apiKey ? "‚úÖ" : "‚ùå"} base:${html(v.baseUrl)}`).join("\n") || "(Á©∫)";
            await sendLong(msg, `üì¶ <b>Â∑≤ÈÖçÁΩÆÊúçÂä°ÂïÜ</b>\n\n${list}`); return;
          }
          if (a0 === "model") {
            const name = args[1]; const p = name && providerOf(name);
            if (!p) { await msg.edit({ text: "‚ùå Êú™ÊâæÂà∞ÊúçÂä°ÂïÜ", parseMode: "html" }); return; }
            const compat = Store.data.compat[name] || detectCompat(name, "", p.baseUrl);
            let models: string[] = [];
            try {
              if (compat === "openai") { const r = await axios.get(trimBase(p.baseUrl) + "/v1/models", { headers: { Authorization: `Bearer ${p.apiKey}` } }); models = (r.data?.data || []).map((x: any) => x.id); }
              else if (compat === "claude") { const r = await axios.get(trimBase(p.baseUrl) + "/v1/models", { headers: { "x-api-key": p.apiKey, "anthropic-version": "2023-06-01" } }); models = (r.data?.data || r.data?.models || []).map((x: any) => x.id || x.slug || x.name); }
              else { models = await listGeminiModels(p); }
            } catch (e: any) { await msg.edit({ text: `‚ùå Ëé∑ÂèñÊ®°ÂûãÂ§±Ë¥•: ${html(e.message || "")}`, parseMode: "html" }); return; }
            const buckets = { chat: [] as string[], search: [] as string[], image: [] as string[], tts: [] as string[] };
            for (const m of models) {
              const ml = String(m).toLowerCase();
              if (/image|dall|sd|gpt-image/.test(ml)) buckets.image.push(m);
              else if (/tts|voice|audio\.speech/.test(ml)) buckets.tts.push(m);
              else { buckets.chat.push(m); buckets.search.push(m); }
            }
            const voiceList = compat === "gemini" ? ["Kore"] : compat === "openai" ? ["alloy","verse","aria","nova"] : [];
            const txt = `üß∞ <b>${html(name)}</b> Ê®°Âûã\n\n<b>chat:</b>\n${buckets.chat.join("\n") || "(Êó†)"}\n\n<b>search:</b>\n${buckets.search.join("\n") || "(Êó†)"}\n\n<b>image:</b>\n${buckets.image.join("\n") || "(Êó†)"}\n\n<b>tts:</b>\n${buckets.tts.join("\n") || "(Êó†)"}\n\n<b>voices:</b>\n${voiceList.join(", ") || "(Êó†)"}`;
            await sendLong(msg, txt); return;
          }
          if (a0 === "update") {
            const name = args[1]; const p = name && providerOf(name);
            if (!p) { await msg.edit({ text: "‚ùå Êú™ÊâæÂà∞ÊúçÂä°ÂïÜ", parseMode: "html" }); return; }
            const replyVal = extractText(await msg.getReplyMessage()).trim();
            const fieldOrVal = args[2] || "";
            const lower = fieldOrVal.toLowerCase();
            if (lower === "apikey" || lower === "baseurl") {
              const val = (args.slice(3).join(" ") || replyVal).trim();
              if (!val) { await msg.edit({ text: "‚ùå ÂèÇÊï∞‰∏çË∂≥", parseMode: "html" }); return; }
              if (lower === "apikey") p.apiKey = val; else { p.baseUrl = val; Store.data.compat[name] = detectCompat(name, "", val); }
            } else {
              const valGuess = ([fieldOrVal, ...args.slice(3)]).join(" ").trim() || replyVal;
              if (!valGuess) { await msg.edit({ text: "‚ùå ÂèÇÊï∞‰∏çË∂≥", parseMode: "html" }); return; }
              if (/^https?:\/\//i.test(valGuess)) { p.baseUrl = valGuess; Store.data.compat[name] = detectCompat(name, "", valGuess); }
              else { p.apiKey = valGuess; }
            }
            Store.data.providers[name] = p; await Store.write(); await msg.edit({ text: `‚úÖ Â∑≤Êõ¥Êñ∞ <b>${html(name)}</b>`, parseMode: "html" }); return;
          }
          if (a0 === "remove") {
            const target = args[1];
            if (!target) { await msg.edit({ text: "‚ùå ÂèÇÊï∞‰∏çË∂≥", parseMode: "html" }); return; }
            if (target.toLowerCase() === "all") {
              Store.data.providers = {}; Store.data.compat = {}; Store.data.models = { chat: "", search: "", image: "", tts: "", voice: "" }; await Store.write();
              await msg.edit({ text: "‚úÖ Â∑≤Ê∏ÖÁ©∫ÊâÄÊúâÊúçÂä°ÂïÜ‰∏éÊ®°ÂûãËÆæÁΩÆ", parseMode: "html" }); return;
            } else {
              delete Store.data.providers[target]; delete Store.data.compat[target];
              for (const k of ["chat","search","image","tts"] as (keyof Models)[]) {
                if ((Store.data.models[k] || "").startsWith(target + " ")) Store.data.models[k] = "";
              }
              await Store.write(); await msg.edit({ text: `‚úÖ Â∑≤ÁßªÈô§ <b>${html(target)}</b>`, parseMode: "html" }); return;
            }
          }
          await msg.edit({ text: "‚ùå Êú™Áü• config Â≠êÂëΩ‰ª§", parseMode: "html" }); return;
        }
        // model
        if (subn === "model") {
          const a0 = (args[0] || "").toLowerCase();
          if (a0 === "list") {
            const m = Store.data.models; const txt = `‚öôÔ∏è <b>ÂΩìÂâçÊ®°Âûã</b>\n\nchat: <code>${html(m.chat || "")}</code>\nsearch: <code>${html(m.search || "")}</code>\nimage: <code>${html(m.image || "")}</code>\ntts: <code>${html(m.tts || "")}</code>\nvoice: <code>${html(m.voice || "")}</code>`; await msg.edit({ text: txt, parseMode: "html" }); return;
          }
          if (a0 === "voice") { Store.data.models.voice = args[1] || ""; await Store.write(); await msg.edit({ text: `‚úÖ ËØ≠Èü≥Èü≥Ëâ≤: <b>${html(Store.data.models.voice || "ÈªòËÆ§")}</b>`, parseMode: "html" }); return; }
          if (a0 === "default") { Store.data.models = { chat: "", search: "", image: "", tts: "", voice: "" }; await Store.write(); await msg.edit({ text: "‚úÖ Â∑≤Ê∏ÖÁ©∫ÊâÄÊúâÂäüËÉΩÊ®°ÂûãËÆæÁΩÆ", parseMode: "html" }); return; }
          if (a0 === "auto") {
            const entries = Object.entries(Store.data.providers);
            if (!entries.length) { await msg.edit({ text: "‚ùå ËØ∑ÂÖà‰ΩøÁî® ai config add Ê∑ªÂä†ÊúçÂä°ÂïÜ", parseMode: "html" }); return; }
            const compatOf = (n: string): Compat => (Store.data.compat[n] || detectCompat(n, "", Store.data.providers[n].baseUrl));
            const modelsBy: Record<string, string[]> = {};
            for (const [n, p] of entries) {
              const c = compatOf(n);
              try {
                if (c === "openai") { const r = await axios.get(trimBase(p.baseUrl) + "/v1/models", { headers: { Authorization: `Bearer ${p.apiKey}` } }); modelsBy[n] = (r.data?.data || []).map((x: any) => x.id); }
                else if (c === "claude") { const r = await axios.get(trimBase(p.baseUrl) + "/v1/models", { headers: { "x-api-key": p.apiKey, "anthropic-version": "2023-06-01" } }); modelsBy[n] = (r.data?.data || r.data?.models || []).map((x: any) => x.id || x.slug || x.name); }
                else { modelsBy[n] = await listGeminiModels(p); }
              } catch { modelsBy[n] = []; }
            }
            const chooseChat = (c: Compat, list: string[]) => c === "openai" ? (list.find(m => /gpt-4o-mini|gpt-4o/i.test(m)) || list[0])
              : c === "claude" ? (list.find(m => /claude-3\.5-sonnet|claude-3-opus|claude-3/i.test(m)) || list[0])
              : (list.find(m => /gemini-2\.0-flash|gemini-1\.5-flash/i.test(m)) || list[0]);
            const chooseImage = (c: Compat, list: string[]) => c === "openai" ? (list.find(m => /gpt-image-1/i.test(m)) || "")
              : c === "gemini" ? (list.find(m => /image-generation/i.test(m)) || "") : "";
            const chooseTTS = (c: Compat, list: string[]) => c === "openai" ? (list.find(m => /^tts-1/i.test(m)) || "")
              : c === "gemini" ? (list.find(m => /-tts/i.test(m)) || "") : "";
            const pickAcross = (order: Compat[], chooser: (c: Compat, list: string[]) => string) => {
              for (const t of order) {
                for (const [n] of entries) {
                  const c = compatOf(n); if (c !== t) continue; const m = chooser(c, modelsBy[n] || []); if (m) return { n, m, c } as { n: string; m: string; c: Compat };
                }
              }
              return null as any;
            };
            const chatSel = pickAcross(["openai","gemini","claude"], chooseChat);
            const searchSel = pickAcross(["openai","gemini","claude"], chooseChat);
            const imageSel = pickAcross(["openai","gemini"], chooseImage);
            const ttsSel = pickAcross(["openai","gemini"], chooseTTS);
            if (!chatSel) { await msg.edit({ text: "‚ùå Êú™ÊâæÂà∞ÂèØÁî® chat/search Ê®°Âûã", parseMode: "html" }); return; }
            Store.data.models.chat = `${chatSel.n} ${chatSel.m}`;
            Store.data.models.search = `${(searchSel || chatSel).n} ${(searchSel || chatSel).m}`;
            Store.data.models.image = imageSel ? `${imageSel.n} ${imageSel.m}` : "";
            Store.data.models.tts = ttsSel ? `${ttsSel.n} ${ttsSel.m}` : "";
            if (!Store.data.models.voice) { Store.data.models.voice = (ttsSel?.c === "gemini") ? "Kore" : (ttsSel?.c === "openai") ? "alloy" : ""; }
            await Store.write(); await msg.edit({ text: "‚úÖ Â∑≤Êô∫ËÉΩÂàÜÈÖç chat/search/image/tts ‰∏éÈü≥Ëâ≤", parseMode: "html" }); return;
          }
          const kind = a0 as keyof Models; if (["chat","search","image","tts"].includes(kind)) {
            const [provider, ...mm] = args.slice(1); const model = (mm.join(" ") || "").trim();
            if (!provider || !model) { await msg.edit({ text: "‚ùå ÂèÇÊï∞‰∏çË∂≥", parseMode: "html" }); return; }
            if (!Store.data.providers[provider]) { await msg.edit({ text: "‚ùå Êú™Áü•ÊúçÂä°ÂïÜ", parseMode: "html" }); return; }
            (Store.data.models as any)[kind] = `${provider} ${model}`; await Store.write(); await msg.edit({ text: `‚úÖ Â∑≤ËÆæÁΩÆ ${kind}: <code>${html((Store.data.models as any)[kind])}</code>`, parseMode: "html" }); return;
          }
          await msg.edit({ text: "‚ùå Êú™Áü• model Â≠êÂëΩ‰ª§", parseMode: "html" }); return;
        }
        // context
        if (subn === "context") {
          const a0 = (args[0] || "").toLowerCase(); const id = chatIdStr(msg);
          if (a0 === "on") { Store.data.contextEnabled = true; await Store.write(); await msg.edit({ text: "‚úÖ Â∑≤ÂºÄÂêØ‰∏ä‰∏ãÊñá", parseMode: "html" }); return; }
          if (a0 === "off") { Store.data.contextEnabled = false; await Store.write(); await msg.edit({ text: "‚úÖ Â∑≤ÂÖ≥Èó≠‰∏ä‰∏ãÊñá", parseMode: "html" }); return; }
          if (a0 === "show") { const items = histFor(id); const t = items.map(x => `${x.role}: ${html(x.content)}`).join("\n"); await sendLong(msg, t || "(Á©∫)"); return; }
          if (a0 === "del") { delete Store.data.histories[id]; await Store.write(); await msg.edit({ text: "‚úÖ Â∑≤Ê∏ÖÁ©∫Êú¨‰ºöËØù‰∏ä‰∏ãÊñá", parseMode: "html" }); return; }
          await msg.edit({ text: "‚ùå Êú™Áü• context Â≠êÂëΩ‰ª§", parseMode: "html" }); return;
        }
        // collapse
        if (subn === "collapse") { const a0 = (args[0] || "").toLowerCase(); Store.data.collapse = a0 === "on"; await Store.write(); await msg.edit({ text: `‚úÖ Ê∂àÊÅØÊäòÂè†: ${Store.data.collapse ? "ÂºÄÂêØ" : "ÂÖ≥Èó≠"}`, parseMode: "html" }); return; }
        // telegraph
        if (subn === "telegraph") {
          const a0 = (args[0] || "").toLowerCase();
          if (a0 === "on") { Store.data.telegraph.enabled = true; await Store.write(); await msg.edit({ text: "‚úÖ Â∑≤ÂºÄÂêØ telegraph", parseMode: "html" }); return; }
          if (a0 === "off") { Store.data.telegraph.enabled = false; await Store.write(); await msg.edit({ text: "‚úÖ Â∑≤ÂÖ≥Èó≠ telegraph", parseMode: "html" }); return; }
          if (a0 === "limit") { const n = parseInt(args[1] || "0"); Store.data.telegraph.limit = isFinite(n) ? n : 0; await Store.write(); await msg.edit({ text: `‚úÖ ÈòàÂÄº: ${Store.data.telegraph.limit}`, parseMode: "html" }); return; }
          if (a0 === "list") { const list = Store.data.telegraph.posts.map((p, i) => `${i + 1}. <a href="${p.url}">${html(p.title)}</a> ${p.createdAt}`).join("\n") || "(Á©∫)"; await sendLong(msg, `üßæ <b>Telegraph ÂàóË°®</b>\n\n${list}`); return; }
          if (a0 === "del") { const t = (args[1] || "").toLowerCase(); if (t === "all") Store.data.telegraph.posts = []; else { const i = parseInt(args[1] || "0") - 1; if (i >= 0) Store.data.telegraph.posts.splice(i, 1); } await Store.write(); await msg.edit({ text: "‚úÖ Êìç‰ΩúÂÆåÊàê", parseMode: "html" }); return; }
          await msg.edit({ text: "‚ùå Êú™Áü• telegraph Â≠êÂëΩ‰ª§", parseMode: "html" }); return;
        }
        // chat/search
        if (subn === "chat" || subn === "search") {
          const replyMsg = await msg.getReplyMessage();
          const isSearch = subn === "search";
          const plain = (args.join(" ") || "").trim();
          const repliedText = extractText(replyMsg).trim();
          const q = (plain || repliedText).trim();
          // ÊîØÊåÅÂØπÂõæÁâáÊ∂àÊÅØÂõûÂ§çËøõË°åËßÜËßâÈóÆÁ≠î
          const hasImage = !!(replyMsg && (replyMsg as any).media);
          if (!q && !hasImage) { await msg.edit({ text: "‚ùå ËØ∑ËæìÂÖ•ÂÜÖÂÆπÊàñÂõûÂ§ç‰∏ÄÊù°Ê∂àÊÅØ", parseMode: "html" }); return; }
          await msg.edit({ text: "üîÑ Â§ÑÁêÜ‰∏≠...", parseMode: "html" });
          const m = pick(isSearch ? "search" : "chat"); if (!m) { await msg.edit({ text: `‚ùå Êú™ËÆæÁΩÆ ${isSearch ? 'search' : 'chat'} Ê®°Âûã`, parseMode: "html" }); return; }
          const p = providerOf(m.provider); if (!p) { await msg.edit({ text: "‚ùå ÊúçÂä°ÂïÜÊú™ÈÖçÁΩÆ", parseMode: "html" }); return; }
          const compat = Store.data.compat[m.provider] || detectCompat(m.provider, m.model, p.baseUrl);

          let content = ""; let usedModel = m.model;
          if (hasImage) {
            try {

              const raw = await msg.client?.downloadMedia(replyMsg as any);
              const buf: Buffer | undefined = typeof raw === 'string' ? Buffer.from(raw) : raw;
              if (!buf || !buf.length) { await msg.edit({ text: "‚ùå Êó†Ê≥ï‰∏ãËΩΩË¢´ÂõûÂ§çÁöÑÂ™í‰Ωì", parseMode: "html" }); return; }
              const b64 = buf.toString('base64');
              content = await chatVision(p, compat, m.model, b64, q);
            } catch (e: any) {
              await msg.edit({ text: `‚ùå Â§ÑÁêÜÂõæÁâáÂ§±Ë¥•Ôºö${html(e?.message || String(e))}`, parseMode: "html" }); return;
            }
          } else {
            const res = await callChat(isSearch ? "search" : "chat", q, msg);
            content = res.content; usedModel = res.model;
          }

          const footTxt = footer(usedModel, isSearch ? "with Search" : "");
          const full = formatQA(q || "(ÂõæÁâá)", content);
          const replyToId = replyMsg?.id || 0; // ‰∏çÂõûÂ§çÁä∂ÊÄÅÊ∂àÊÅØ
          if (Store.data.telegraph.enabled && Store.data.telegraph.limit > 0 && full.length > Store.data.telegraph.limit) {
            const url = await createTGPage("TeleBox AI", content);
            if (url) {
              Store.data.telegraph.posts.unshift({ title: (q || "ÂõæÁâá").slice(0, 30) || "AI", url, createdAt: nowISO() });
              Store.data.telegraph.posts = Store.data.telegraph.posts.slice(0, 10);
              await Store.write();
              if (replyToId) { await sendLongReply(msg, replyToId, `üì∞ <a href="${url}">ÂÜÖÂÆπËæÉÈïøÔºåÂ∑≤ÂàõÂª∫ Telegraph</a>`, { collapse: Store.data.collapse }, footTxt); }
              else { await sendLong(msg, `üì∞ <a href="${url}">ÂÜÖÂÆπËæÉÈïøÔºåÂ∑≤ÂàõÂª∫ Telegraph</a>`, { collapse: Store.data.collapse }, footTxt); }
              if (replyToId) { try { await msg.delete(); } catch {} }
               return;
            }
          }
          if (replyToId) { await sendLongReply(msg, replyToId, full, { collapse: Store.data.collapse }, footTxt); }
          else { await sendLong(msg, full, { collapse: Store.data.collapse }, footTxt); }
          if (replyToId) { try { await msg.delete(); } catch {} }
           return;
        }
        // image
        if (subn === "image") {
          const replyMsg = await msg.getReplyMessage();
          const prm = (args.join(" ") || "").trim() || extractText(replyMsg).trim();
          if (!prm) { await msg.edit({ text: "‚ùå ËØ∑ËæìÂÖ•ÊèêÁ§∫ËØç", parseMode: "html" }); return; }
          const m = pick("image"); if (!m) { await msg.edit({ text: "‚ùå Êú™ËÆæÁΩÆ image Ê®°Âûã", parseMode: "html" }); return; }
          const p = providerOf(m.provider); if (!p) { await msg.edit({ text: "‚ùå ÊúçÂä°ÂïÜÊú™ÈÖçÁΩÆ", parseMode: "html" }); return; }
          const compat = Store.data.compat[m.provider] || detectCompat(m.provider, m.model, p.baseUrl);
          await msg.edit({ text: "üé® ÁîüÊàê‰∏≠...", parseMode: "html" });
          const replyToId = replyMsg?.id || 0;
          if (compat === "openai") {
            const b64 = await imageOpenAI(p, m.model, prm);
            if (!b64) { await msg.edit({ text: "‚ùå ÂõæÁâáÁîüÊàêÂ§±Ë¥•ÔºöÊúçÂä°Êó†ÊúâÊïàËæìÂá∫", parseMode: "html" }); return; }
            const buf = Buffer.from(b64, "base64"); const file: any = Object.assign(buf, { name: "ai.png" });

            await msg.client?.sendFile(msg.peerId, { file, caption: `üñºÔ∏è ${html(prm)}` + footer(m.model), parseMode: "html", replyTo: replyToId || undefined });
            await msg.delete(); return;
          } else if (compat === "gemini") {
            const { image, text, mime } = await imageGemini(p, m.model, prm);
            if (image) {
              const ext = (mime || "image/png").includes("png") ? "png" : (mime || "").includes("jpeg") ? "jpg" : "png";
              const file: any = Object.assign(image, { name: `ai.${ext}` });

              await msg.client?.sendFile(msg.peerId, { file, caption: `üñºÔ∏è ${html(prm)}` + footer(m.model), parseMode: "html", replyTo: replyToId || undefined });
              await msg.delete(); return;
            }

            if (text) {
              const textOut = formatQA(prm, text);
              if (replyToId) { await sendLongReply(msg, replyToId, textOut, { collapse: Store.data.collapse }, footer(m.model)); }
              else { await sendLong(msg, textOut, { collapse: Store.data.collapse }, footer(m.model)); }
              await msg.delete(); return;
            }
            await msg.edit({ text: "‚ùå ÂõæÁâáÁîüÊàêÂ§±Ë¥•ÔºöÊúçÂä°Êó†ÊúâÊïàËæìÂá∫", parseMode: "html" }); return;
          } else {
            await msg.edit({ text: "‚ùå ÂΩìÂâçÊúçÂä°ÂïÜ‰∏çÊîØÊåÅÂõæÁâáÁîüÊàêÂäüËÉΩ", parseMode: "html" }); return;
          }
        }
        // audio | searchaudioÔºàÂÖàÂõûÁ≠îÔºåÂÜçËØ≠Èü≥ÂêàÊàêÔºâ
        if (subn === "audio" || subn === "searchaudio") {
          const replyMsg = await msg.getReplyMessage();
          const plain = (args.join(" ") || "").trim();
          const repliedText = extractText(replyMsg).trim();
          const q = (plain || repliedText).trim();
          if (!q) { await msg.edit({ text: "‚ùå ËØ∑ËæìÂÖ•ÂÜÖÂÆπÊàñÂõûÂ§ç‰∏ÄÊù°Ê∂àÊÅØ", parseMode: "html" }); return; }

          await msg.edit({ text: "üîÑ Â§ÑÁêÜ‰∏≠...", parseMode: "html" });
          const isSearch = subn === "searchaudio";
          const res = await callChat(isSearch ? "search" : "chat", q, msg);
          const content = res.content;

          const mtts = pick("tts"); if (!mtts) { await msg.edit({ text: "‚ùå Êú™ËÆæÁΩÆ tts Ê®°Âûã", parseMode: "html" }); return; }
          const ptts = providerOf(mtts.provider); if (!ptts) { await msg.edit({ text: "‚ùå ÊúçÂä°ÂïÜÊú™ÈÖçÁΩÆ", parseMode: "html" }); return; }
          const compat = Store.data.compat[mtts.provider] || detectCompat(mtts.provider, mtts.model, ptts.baseUrl);
          const defaultVoice = compat === "gemini" ? "Kore" : "alloy"; const voice = Store.data.models.voice || defaultVoice;

          await msg.edit({ text: "üîä ÂêàÊàê‰∏≠...", parseMode: "html" });
          const replyToId = replyMsg?.id || 0;

          if (compat === "openai") {
            const audio = await ttsOpenAI(ptts, mtts.model, content, voice);
            const file: any = Object.assign(audio, { name: "ai.ogg" });
            await msg.client?.sendFile(msg.peerId, {
              file,
              caption: formatQA(q, content) + footer(mtts.model, isSearch ? ("Audio with Search (" + html(voice) + ")") : ("Audio (" + html(voice) + ")")),
              parseMode: "html",
              replyTo: replyToId || undefined,
              attributes: [new Api.DocumentAttributeAudio({ duration: 0, voice: true })],
            });
            await msg.delete();
            return;
          } else if (compat === "gemini") {
            const { audio, mime } = await ttsGemini(ptts, mtts.model, content, voice);
            if (audio) {
              const ext = (mime || "audio/ogg").includes("wav")
                ? "wav"
                : (mime || "").includes("mpeg") || (mime || "").includes("mp3")
                ? "mp3"
                : "ogg";
              const file: any = Object.assign(audio, { name: `ai.${ext}` });
              await msg.client?.sendFile(msg.peerId, {
                file,
                caption: formatQA(q, content) + footer(mtts.model, isSearch ? ("Audio with Search (" + html(voice) + ")") : ("Audio (" + html(voice) + ")")),
                parseMode: "html",
                replyTo: replyToId || undefined,
                attributes: [new Api.DocumentAttributeAudio({ duration: 0, voice: true })],
              });
              await msg.delete();
              return;
            } else {
              await msg.edit({ text: "‚ùå ËØ≠Èü≥ÂêàÊàêÂ§±Ë¥•ÔºöÊúçÂä°Êó†ÊúâÊïàËæìÂá∫", parseMode: "html" });
              return;
            }
          } else {
            await msg.edit({ text: "‚ùå ÂΩìÂâçÊúçÂä°ÂïÜ‰∏çÊîØÊåÅËØ≠Èü≥ÂêàÊàêÂäüËÉΩ", parseMode: "html" });
            return;
          }
        }

        // tts
        if (subn === "tts") {
          const replyMsg = await msg.getReplyMessage();
          const t = (args.join(" ") || "").trim() || extractText(replyMsg).trim();
          if (!t) { await msg.edit({ text: "‚ùå ËØ∑ËæìÂÖ•ÊñáÊú¨", parseMode: "html" }); return; }
          const m = pick("tts"); if (!m) { await msg.edit({ text: "‚ùå Êú™ËÆæÁΩÆ tts Ê®°Âûã", parseMode: "html" }); return; }
          const p = providerOf(m.provider)!; const compat = Store.data.compat[m.provider] || detectCompat(m.provider, m.model, p.baseUrl);
          const defaultVoice = compat === "gemini" ? "Kore" : "alloy"; const voice = Store.data.models.voice || defaultVoice;
          await msg.edit({ text: "üîä ÂêàÊàê‰∏≠...", parseMode: "html" });
          const replyToId = replyMsg?.id || 0;
          if (compat === "openai") {
            const audio = await ttsOpenAI(p, m.model, t, voice);
            const file: any = Object.assign(audio, { name: "ai.ogg" });
            const sent: any = await msg.client?.sendFile(msg.peerId, { file, caption: `<b>ÊñáÊú¨:</b> ${html(t)}` + footer(m.model, `TTS (${html(voice)})`), parseMode: "html", replyTo: replyToId || undefined, attributes: [new Api.DocumentAttributeAudio({ duration: 0, voice: true })] });
            await msg.delete(); return;
          } else if (compat === "gemini") {
            const { audio, mime } = await ttsGemini(p, m.model, t, voice);
            if (audio) {
              const ext = (mime || "audio/ogg").includes("wav")
                ? "wav"
                : (mime || "").includes("mpeg") || (mime || "").includes("mp3")
                ? "mp3"
                : "ogg";
              const file: any = Object.assign(audio, { name: `ai.${ext}` });
              await msg.client?.sendFile(msg.peerId, {
                file,
                caption: `<b>ÊñáÊú¨:</b> ${html(t)}` + footer(m.model, `TTS (${html(voice)})`),
                parseMode: "html",
                replyTo: replyToId || undefined,
                attributes: [new Api.DocumentAttributeAudio({ duration: 0, voice: true })],
              });
              await msg.delete();
              return;
            } else {
              await msg.edit({ text: "‚ùå ËØ≠Èü≥ÂêàÊàêÂ§±Ë¥•ÔºöÊúçÂä°Êó†ÊúâÊïàËæìÂá∫", parseMode: "html" });
              return;
            }
          } else {
            await msg.edit({ text: "‚ùå ÂΩìÂâçÊúçÂä°ÂïÜ‰∏çÊîØÊåÅËØ≠Èü≥ÂêàÊàêÂäüËÉΩ", parseMode: "html" });
            return;
          }
        }
        await msg.edit({ text: "‚ùå Êú™Áü•Â≠êÂëΩ‰ª§", parseMode: "html" });
        return;
      } catch (e: any) {
        await msg.edit({ text: `‚ùå ÊâßË°åÂ§±Ë¥•Ôºö${html(e?.message || String(e))}` , parseMode: "html" });
      }
    }
  };
}

export default new AiPlugin();
